(declaim (optimize safety)) ;; as befits a test

;;; Unit tests for sp_5, the implementation of the field of five
;;; elements.  To use these tests, make sure sparse-elt.lisp, sparse-v.lisp
;;; and csparse.lisp have been loaded, and then call
;;; (def-sp-p 5)
;;; (compile-file "unit-test-5")
;;; (load "unit-test-5")

;;; Omits some tests that don't depend much on the ring, since we
;;; assume the tests over Z have already run.

(assert (fboundp 'make-sp-5) ()
  "Before running these tests, please execute (def-sp-p 5).")

;;; -------------------- Tests for sparse-elt.lisp --------------------

(dotimes (q 5)
  (let ((qq (make-sp-5 17 q)))
    (assert (= (sp-i-func qq) (sp-i qq) 17))
    (assert (sp-field-p qq))
    (assert (equalp (sp-f_p-p qq) 5))
    (assert (not (sp-z-p qq)))
    (assert (equalp qq (sp-embed-z qq (expt q 5)))) ;; Fermat's little theorem
    (assert (sp-= qq (sp-embed-z qq (expt q 5) 23)))
    (let ((qq23 (copy-sp qq 23)))
      (assert (equalp qq23 (make-sp-5 23 q)))
      (assert (equalp qq23 (copy-sp qq (+ 13 10))))
      (assert (equalp qq23 (sp-embed-z qq (expt q 5) 23))))
    (assert (eq qq (copy-sp qq 17)))
    (shh2::sp-integrity-check qq)
    (labels ((iff (bool1 bool2) (if bool1 bool2 (not bool2))))
      (assert (iff (sp-zerop qq) (= q 0)))
      (assert (iff (sp-onep qq) (= q 1)))
      (assert (iff (sp-neg-one-p qq) (= q 4)))
      (assert (iff (sp-unitp qq) (/= q 0)))
      (assert (iff (sp-zerop qq) (zerop (sp-euc-norm qq))))
      (assert (iff (not (sp-zerop qq)) (= 1 (sp-euc-norm qq)))))
    (assert (equalp (sp-negate qq) (make-sp-5 17 (- q))))
    (assert (equalp (sp-negate qq 23) (make-sp-5 23 (- q))))
    (multiple-value-bind (x y) (sp-pretty-associate qq)
      (assert (equalp x (make-sp-5 17 (if (zerop q) 0 1))))
      (assert (equalp y (make-sp-5 17 (if (zerop q) 1 q)))))
    (dotimes (r 5)
      (let ((rr (make-sp-5 19 r)))
	(assert (equalp (sp-add qq rr) (make-sp-5 17 (+ q r))))
	(assert (equalp (sp-add qq rr 23) (make-sp-5 23 (+ q r))))
	(assert (equalp (sp-subtract qq rr) (make-sp-5 17 (- q r))))
	(assert (equalp (sp-subtract qq rr 23) (make-sp-5 23 (- q r))))
	(assert (equalp (sp-mult qq rr) (make-sp-5 17 (* q r))))
	(assert (equalp (sp-mult qq rr 23) (make-sp-5 23 (* q r))))
	(unless (sp-zerop rr)
	  (assert (sp-divides rr qq))
	  (assert (equalp qq (sp-mult (sp-divided-by qq rr) rr)))
	  (assert (equalp (copy-sp qq 19)
			  (sp-mult rr (sp-divided-by qq rr))))
	  (assert (equalp (sp-negate qq)
			  (sp-mult (sp-neg-closest-quotient qq rr) rr)))
	  (assert (equalp (sp-negate (copy-sp qq 19))
			  (sp-mult rr (sp-neg-closest-quotient qq rr))))
	  (assert (sp-zerop (sp-rounded-rem qq rr))))
	(assert (sp-= (sp-add qq rr) (sp-add rr qq)))
	(assert (not (equalp (sp-add qq rr) (sp-add rr qq))))))))

;;; -------------------- Tests for sparse-v.lisp --------------------

(labels ((vl (lyst) (input-sparse-v lyst #'make-sp-5))
	 (cen (la lc)
	   (do ((ta la (rest ta))
		(tc lc (rest tc))
		(i 0 (1+ i))
		(ans '() (if (and (zerop (rem (first ta) 5))
				  (not (zerop (rem (first tc) 5))))
			     (cons i ans)
			   (if (and (not (zerop (rem (first ta) 5)))
				    (zerop (rem (first tc) 5)))
			       (cons (- -1 i) ans)
			     ans))))
	       ((endp ta) (nreverse ans)))))
  (labels ((add-subtr-test (l1 l2)
	     (multiple-value-bind (ans census) (v-add (vl l1) (vl l2))
		  (assert (equalp ans (vl (mapcar #'+ l1 l2))))
		  (assert (equal census (cen l1 (mapcar #'+ l1 l2)))))
	     (multiple-value-bind (ans census) (v-subtract (vl l1) (vl l2))
		  (assert (equalp ans (vl (mapcar #'- l1 l2))))
		  (assert (equal census (cen l1 (mapcar #'- l1 l2)))))
	     (assert (equalp (v-add-nondestr (vl l1) (vl l2))
			     (vl (mapcar #'+ l1 l2))))
	     (assert (equalp (v-subtract-nondestr (vl l1) (vl l2))
			     (vl (mapcar #'- l1 l2))))))
    (add-subtr-test '(3 0 7 0) '(0 6 0 8))
    (add-subtr-test '(0 6 0 8) '(3 0 7 0))
    (add-subtr-test '(1 2 3) '(4 5 6))
    (add-subtr-test '(4 5 6) '(1 2 3))
    (add-subtr-test '(3 2 3) '(4 -2 6))
    (add-subtr-test '(4 -2 6) '(3 2 3))
    (dotimes (a 3)
      (dotimes (b 3)
	(dotimes (c 3)
	  (dotimes (d 3)
	    (dotimes (e 3)
	      (dotimes (f 3)
		(add-subtr-test (list (1- a) (1- b) (1- c))
				(list (1- d) (1- e) (1- f))))))))))
    (labels ((scmult-test (l1 c)
	       (assert (equalp (v-scalar-mult (vl l1) (make-sp-5 -1 c))
			       (vl (mapcar #'(lambda (v) (* c v)) l1)))))
	     (negate-test (l1)
	       (assert (equalp (v-negate (vl l1))
			       (vl (mapcar #'- l1))))
	       (assert (equalp (v-negate-nondestr (vl l1))
			       (vl (mapcar #'- l1)))))
	     (alter-test (l1 c l2)
	       (multiple-value-bind (ans census) (v-alter (vl l1) (make-sp-5 -1 c) (vl l2))
		 (assert (equalp ans (vl (mapcar #'(lambda (x1 x2)
						     (+ x1 (* c x2)))
						 l1 l2))))
		 (assert (equal census (cen l1 (mapcar #'(lambda (x1 x2)
							   (+ x1 (* c x2)))
						       l1 l2))))))
	     (dot-test (l1 l2)
	       (let ((dot (v-dot (vl l1) (vl l2))))
		 (assert (sp-= (or dot (make-sp-5 -1 0))
			       (make-sp-5 -1 (apply #'+ (mapcar #'* l1 l2))))))))
      (dotimes (a1 3)
	(dotimes (a2 3)
	  (dotimes (a3 3)
	    (negate-test (list (1- a1) (1- a2) (1- a3)))
	    (dotimes (c 3)
	      (scmult-test (list (1- a1) (1- a2) (1- a3)) c)
	      (dotimes (b1 3)
		(dotimes (b2 3)
		  (dotimes (b3 3)
		    (alter-test (list (1- a1) (1- a2) (1- a3))
				(1+ c)
				(list (1- b1) (1- b2) (1- b3)))
		    (when (zerop c)
		      (dot-test (list (1- a1) (1- a2) (1- a3))
				(list (1- b1) (1- b2) (1- b3))))))))))))
    (labels ((alter-elt-test (l i1 c i2)
	       (let ((a (vl l))
		     (ans-l (copy-list l)))
		 (setf (elt ans-l i1) (+ (elt ans-l i1) (* c (elt ans-l i2))))
		 (multiple-value-bind (ans census) (v-alter-elt a i1 (make-sp-5 -1 c) i2)
		   (assert (equalp (vl ans-l) ans))
		   (assert (equal (cen l ans-l) census)))))
	     (negate-elt-test (l i)
	       (assert (equalp (v-negate-elt (vl l) i)
			       (vl (mapcar #'(lambda (k0 k1)
					       (if (= k1 i) (- k0) k0))
					   l '(0 1 2))))))
	     (get-test (l i)
	       (assert (equalp (v-get (vl l) i)
			       (if (zerop (elt l i))
				   nil
				 (make-sp-5 i (elt l i))))))
	     (set-test (l i c)
	       (let ((ans-l (mapcar #'(lambda (old-val ii)
					(if (= ii i) c old-val))
				    l '(0 1 2))))
		 (multiple-value-bind (ans census) (v-set (vl l) i (make-sp-5 -1 c))
		   (assert (equalp (vl ans-l) ans))
		   (assert (equal (cen l ans-l) census))))))
      (dotimes (a1 3)
	(dotimes (a2 3)
	  (dotimes (a3 3)
	    (dotimes (i1 3)
	      (negate-elt-test (list (1- a1) (1- a2) (1- a3)) i1)
	      (get-test (list (1- a1) (1- a2) (1- a3)) i1)
	      (dotimes (c 2)
		(set-test (list (1- a1) (1- a2) (1- a3)) i1 c)
		(dotimes (i2 3)
		  (alter-elt-test (list (1- a1) (1- a2) (1- a3))
				  i1 (1+ c) i2)))))))))

;;; -------------------- Tests for csparse.lisp --------------------

;;; Tests for Hermite normal form, which here is Gaussian elimination.
(let ((a (input-csparse 3 2 '(8 19 -3 7 6 5) #'make-sp-5)))
  (hnf-f a 0)
  (assert (and (csparse-get a 0 0)
	       (csparse-get a 0 1)
	       (csparse-get a 1 0)
	       (not (csparse-get a 1 1))
	       (not (csparse-get a 2 0))
	       (csparse-get a 2 1)
	       (equalp (sp-divided-by (csparse-get a 0 1) (csparse-get a 2 1))
		       (make-sp-5 0 -1))
	       (equalp (sp-divided-by (csparse-get a 0 0) (csparse-get a 1 0))
		       (make-sp-5 0 2)))))	       
(let ((a (input-csparse 3 2 '(8 19 -3 7 6 5) #'make-sp-5))) ;; same
  (shh2::hit-with-disk-hnf a)
  (hnf-f a 0)
  (assert (and (csparse-get a 0 0)
	       (csparse-get a 0 1)
	       (csparse-get a 1 0)
	       (not (csparse-get a 1 1))
	       (not (csparse-get a 2 0))
	       (csparse-get a 2 1)
	       (equalp (sp-divided-by (csparse-get a 0 1) (csparse-get a 2 1))
		       (make-sp-5 0 -1))
	       (equalp (sp-divided-by (csparse-get a 0 0) (csparse-get a 1 0))
		       (make-sp-5 0 2)))))
(let ((a (input-csparse 3 3 '(1 3 9 1 4 16 1 7 49) #'make-sp-5)))
  (hnf-f a 0)
  (dotimes (i 3)
    (dotimes (j 3)
      (let ((eij (csparse-get a i j)))
	(unless (if (= i j) eij (not eij))
	  (error "On 3 by 3 Vandermonde, hnf has wrong (~D,~D) entry."
		 i j))))))
(let ((a (input-csparse 3 3 '(1 3 9 1 4 16 1 7 49) #'make-sp-5))) ;; same
  (shh2::hit-with-disk-hnf a)
  (dotimes (i 3)
    (dotimes (j 3)
      (let ((eij (csparse-get a i j)))
	(unless (if (= i j) eij (not eij))
	  (error "On 3 by 3 Vandermonde, disk hnf has wrong (~D,~D) entry."
		 i j))))))

(do ((a 0 (1+ a)))
    ((= a 5))
  (do ((b 0 (1+ b)))
      ((= b a))
    (do ((d 0 (1+ d)))
	((= d 5))
      (dotimes (w 5)
	(dotimes (x 5)
	  (dotimes (y 5)
	    (dotimes (z 5)
	      (when (= (abs (- (* w z) (* x y))) 1)
		(let ((aa (m-mult
			   (input-csparse 2 2 (list a b 0 d) #'make-sp-5)
			   (input-csparse 2 2 (list w x y z) #'make-sp-5))))
		  (hnf-f aa)
		  (assert
		      (if (and (/= a 0) (/= d 0))
			  (and (= (m-num-cols aa) 2)
			       (csparse-get aa 0 0)
			       (not (csparse-get aa 0 1))
			       (not (csparse-get aa 1 0))
			       (csparse-get aa 1 1)
			       (let ((det (sp-mult (csparse-get aa 0 0)
						   (csparse-get aa 1 1))))
				 (or (sp-= det (make-sp-5 -1 (* a d)))
				     (sp-= det (make-sp-5 -1 (* -1 a d))))))
			(if (and (= d 0) (or (/= a 0) (/= b 0)))
			    (and (= (m-num-cols aa) 1)
				 (csparse-get aa 0 0)
				 (not (csparse-get aa 1 0)))
			  (if (/= d 0) ;; and a = 0
			      (and (= (m-num-cols aa) 1)
				   (if (/= b 0)
				       (csparse-get aa 0 0)
				     (not (csparse-get aa 0 0)))
				   (csparse-get aa 1 0)
				   (if (/= b 0)
				       (sp-= (sp-divided-by
					      (csparse-get aa 0 0)
					      (csparse-get aa 1 0))
					     (make-sp-5
					      -1
					      (ecase d ;; b/d mod 5
						(1 b)
						(2 (* 3 b))
						(3 (* 2 b))
						(4 (- b)))))
				       t))
			    ;; a = b = d = 0
			    (and (= (m-num-cols aa) 0)
				 (m-zerop aa))))) ()
		    "Gauss elim: (~D ~D | 0 ~D) * (~D ~D | ~D ~D) mod 5"
		    a b d w x y z))))))))))

(let ((p-list '()))
  (block first-few-primes
    (let ((ct 0))
      (do-mset (p *primes*)
	(push p p-list)
	(incf ct)
	(when (= ct 30)
	  (return-from first-few-primes)))))
  ;; Test for minor trick.
  (do ((minor-width 1 (1+ minor-width)))
      ((> minor-width 4))
    (let ((*allow-minor-trick* t)
	  (*minor-trick-threshold* 0.0)
	  (*minor-trick-col-func* #'(lambda (m0)
				      (declare (ignore m0))
				      minor-width))
	  (a (input-csparse 3 10 (reverse p-list) #'make-sp-5)))
      (let ((b (make-snf a t t nil)))
	(shh2::integrity-check b)
	(assert (= (rank b) 3))
	(assert (= (num-units b) 3))))))

;;; Tests for csparse arithmetic.
(labels ((i22 (lyst)
           (input-csparse 2 2 lyst #'make-sp-5)))
  (let ((pp (i22 '(5 -13 -7 19))))
    ;;  5 -13
    ;; -7  19
    (assert (equalp (m-add pp pp) (i22 '(10 -26 -14 38))))
    (assert (equalp (m-negate pp) (i22 '(-5 13 7 -19))))
    (assert (equalp (m-mult pp pp) (i22 '(116 -312 -168 452))))
    (assert (equalp (m-subtract (m-mult pp pp) pp)
		    (i22 '(111 -299 -161 433))))
    (assert (equalp (m-mult (shh2::make-perm2 0 1) (csparse-copy pp))
                    (i22 '(-7 19 5 -13))))
    (assert (equalp (m-mult (csparse-copy pp) (shh2::make-perm2 0 1))
                    (i22 '(-13 5 19 -7))))
    (let ((p01 (make-perm (make-array 2 :initial-contents '(1 0)))))
      (assert (equalp (m-mult p01 (csparse-copy pp))
		      (i22 '(-7 19 5 -13))))
      (assert (equalp (m-mult (csparse-copy pp) p01)
		      (i22 '(-13 5 19 -7)))))	
    (assert (equalp (m-mult (shh2::make-transv 1 (make-sp-5 0 1))
			    (csparse-copy pp))
                    (i22 '(-2 6 -7 19))))
    (assert (equalp (m-mult (shh2::make-transv 0 (make-sp-5 1 1))
			    (csparse-copy pp))
                    (i22 '(5 -13 -2 6))))
    (assert (equalp (m-mult (csparse-copy pp)
			    (shh2::make-transv 1 (make-sp-5 0 1)))
                    (i22 '(5 -8 -7 12))))
    (assert (equalp (m-mult (csparse-copy pp)
			    (shh2::make-transv 0 (make-sp-5 1 1)))
                    (i22 '(-8 -13 12 19))))
    (assert (equalp (m-transpose (csparse-copy pp)) (i22 '(5 -7 -13 19))))
    (let ((pps (make-snf pp)))
      ;; To repeat, pp is
      ;;  5 -13
      ;; -7  19
      (shh2::integrity-check pps)
      (assert (= (rank pps) (num-units pps) 2))
      (assert (endp (torsion pps)))
      (assert (m-image-contained-in-image (i22 '(13 5 -19 -7)) pps))
      (assert (m-image-contained-in-image (i22 '(-26 0 38 0)) pps))
      (assert (m-image-contained-in-image (i22 '(-29 63 43 -89)) pps)))
    (let ((pps (make-snf pp t t nil t)))
      ;; Same as previous test with pps, but writes P's and Q's to disk.
      (shh2::integrity-check pps)
      (assert (= (rank pps) (num-units pps) 2))
      (assert (endp (torsion pps)))
      (assert (m-image-contained-in-image (i22 '(13 5 -19 -7)) pps))
      (assert (m-image-contained-in-image (i22 '(-26 0 38 0)) pps))
      (assert (m-image-contained-in-image (i22 '(-29 63 43 -89)) pps)))
    (let ((qq (make-csparse-zero 2 2)))
      (csparse-set qq (make-sp-5 0 5) 0)
      (csparse-set qq (make-sp-5 0 -13) 1)
      (csparse-set qq (make-sp-5 1 -7) 0)
      (csparse-set qq (make-sp-5 1 19) 1)
      (assert (equalp pp qq)))))
(dotimes (a 3)
  (dotimes (b 3)
    (dotimes (c 3)
      (dotimes (d 3)
        (dotimes (e 3)
          (dotimes (f 3)
            (dotimes (g 3)
              (let ((args (mapcar #'1- (list a b c d e f g))))
                (shh2::integrity-check (make-snf (input-csparse 3 3 args #'make-sp-5)))
                (shh2::integrity-check (make-snf (input-csparse 3 5 args #'make-sp-5)))
                (shh2::integrity-check (make-snf (input-csparse 5 3 args #'make-sp-5)))))))))))
