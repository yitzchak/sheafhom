(in-package shh2)

(declaim (optimize safety)) ;; till we write a full suite of unit tests

;;; ------------------------- Contract for group -------------------------

;;; Every group must implement the generic functions in this section.
;;; You many want to provide implementations for other generic
;;; functions, and for print-object.

(defclass group (mset)
  ()
  (:documentation "A group is a set of group-elt objects satisfying the group axioms--existence of an identity element and closure under mult-two and inverse.  [Immutable...]  A subclass of group only needs to implement the required mset methods and the conj-class-... methods.  See group-std-conj-char for default implementations of the conj-class-... methods."))

(defgeneric conj-class (x gg)
  (:documentation "The group's gg conjugacy classes must have a fixed numbering 0, 1, ....  If x = j is such an integer, this function returns an mset holding the j-th conjugacy class.  If x is a group-elt, the function returns the conjugacy class of x.  Note: if you implement the x = j version, you don't have to implement the x = group-elt version."))

(defgeneric conj-class-num (gg)
  (:documentation "Returns the number of conjugacy classes in the group gg."))

(defgeneric conj-class-index (g gg)
  (:documentation "Returns j such that g is in the j-th conjugacy class of the group gg.  The inverse of (conj-class j gg)."))

(defgeneric gp-char (i gg)
  (:documentation "Returns the i-th group character [gp-char] of gg.  The integer i must be between 0 [inclusive] and (conj-class-num gg) [exclusive].  ...A class function for a group gg is a function from gg to the complex numbers that is constant on conjugacy classes.  In our implementation, it is a simple-vector whose j-th entry is for the conjugacy class (conj-class j gg).  ...A group character is the character of a complex representation of gg, or an element of the Z-lattice generated by such characters [a virtual character].  In practice, the difference between a group character and a class function is that the inner product of two group characters on gg belongs to Z.  We compute these inner products over the complexes [i.e., in floating point] and round off the result to the nearest integer.  ...See gp-char-value."))

;;; -  -  -  -  -  -  -  -  Related methods   -  -  -  -  -  -  -  -

(defmacro do-conj-class ((c gg &optional result) &body body)
  "For each conjugacy class in the group gg, binds c to the conjugacy class and runs the body."
  (let ((j (gensym)))
    `(dotimes (,j (conj-class-num ,gg) ,result)
       (let ((,c (conj-class ,j ,gg)))
	 ,@body))))

(defmacro do-conj-class-rep ((r gg &optional result) &body body)
  "For each conjugacy class in the group gg, binds r to a representative of the conjugacy class and runs the body."
  (let ((j (gensym)))
    `(dotimes (,j (conj-class-num ,gg) ,result)
       (let ((,r (conj-class-rep ,j ,gg)))
	 ,@body))))

(defmethod conj-class ((g group-elt) (gg group))
  (conj-class (conj-class-index g gg) gg))

(defgeneric conj-class-rep (x gg)
  (:documentation "The group's gg conjugacy classes must have a fixed numbering 0, 1, ....  If x = j is such an integer, this function returns some representative element of the j-th conjugacy class.  It should return the same element each time, one that's easy for humans to read.  If x is a group-elt, the function returns the same representative for the conjugacy class of x.  Note: if you implement the x = j version, you don't have to implement the x = group-elt version."))

(defmethod conj-class-rep ((g group-elt) (gg group))
  (conj-class-rep (conj-class-index g gg) gg))

(defmethod conj-class-rep ((j integer) (gg group))
  (mset-get-one-elt (conj-class j gg)))

(defgeneric gp-char-value (chi x &optional gg)
  (:documentation "If chi is a group character as returned by (gp-char i), gp-char-value returns the value of chi at x.  Here x is either an integer j standing for the j-th conjugacy class of the group gg, or x is a group-elt in gg.  In the x = j case, gg can be omitted."))

(defmethod gp-char-value ((chi vector) (j integer) &optional gg)
  (declare (ignore gg))
  (svref chi j))

(defmethod gp-char-value ((chi vector) (g group-elt) &optional gg)
  (svref chi (conj-class-index g gg)))

;;; --------------- Standard conj class implementation ---------------

(defclass group-std-conj-char (group)
  ((cc-vec :reader cc-vec :initform nil :type (or vector null))
   (g-to-j :reader g-to-j :initform nil :type (or hash-table null))
   (cc-sorter :initform #'std-cc-sorter :type function)
   (char-table :initform (make-array 0 :adjustable t :fill-pointer t)
	       :type vector))
  (:documentation "A mixin for groups that provides a standard implementation of the conjugacy class and group character functions.  The group must be small enough that all its elements can fit in a hash-table.  cc-vec holds a vector of hash-sets giving the conjugacy classes.  g-to-j maps elements in the j-th class to j.  cc-vec is sorted by cc-sorter.  char-table holds all the group characters we've found so far, as an orthonormal set."))

(defun std-cc-sorter (cc1 cc2)
  (let ((sz1 (mset-size cc1))
	(sz2 (mset-size cc2)))
    (cond ((< sz1 sz2) t)
	  ((> sz1 sz2) nil)
	  ((> sz1 1) nil)
	  ((identityp (mset-get-one-elt cc1)) t)
	  (t nil))))

(defmethod conj-class-num ((gg group-std-conj-char))
  (unless (cc-vec gg)
    (fill-in-std-conj gg))
  (length (cc-vec gg)))

(defmethod conj-class ((j integer) (gg group-std-conj-char))
  (unless (cc-vec gg)
    (fill-in-std-conj gg))
  (svref (cc-vec gg) j))

(defmethod conj-class-index ((g group-elt) (gg group-std-conj-char))
  (unless (cc-vec gg)
    (fill-in-std-conj gg))
  (gethash (hash-key g) (g-to-j gg)))

(defun fill-in-std-conj (gg)
  "Called internally on group-std-conj-char objects to make the conjugacy classes.  The user should never call it directly."
  (with-slots (cc-vec g-to-j cc-sorter) gg
    (setf g-to-j (make-hash-table :test #'equalp :size (order gg)))
    (let ((cc-stack '()))
      (do-mset (g gg)
	(unless (has-key (hash-key g) g-to-j)
	  (let ((c (make-hash-table :test #'equalp)))
	    (do-mset (h gg)
	      (let* ((g1 (conj-y-x-yinv g h))
		     (k1 (hash-key g1)))
		(unless (has-key k1 c)
		  (puthash k1 g1 c)
		  (puthash k1 t g-to-j)))) ;; t will be j later
	    (push (make-set c) cc-stack))))
      (setf cc-vec (make-array (length cc-stack) :initial-contents cc-stack)))
    (setf cc-vec (sort cc-vec cc-sorter))
    (dotimes-f (j (length cc-vec))
      (do-mset (g (svref cc-vec j))
	(puthash (hash-key g) j g-to-j)))))

(defmethod gp-char ((i integer) (gg group))
  (with-slots (char-table) gg
    (when (< (length char-table) (conj-class-num gg))
      (fill-in-char-table gg))
    (aref char-table i)))

(defgeneric fill-in-char-table (gg)
  (:documentation "Called internally by the system to compute the complete character table of the group gg.  The user should not call it; instead, use gp-char and gp-char-value."))

(defmethod fill-in-char-table ((gg group-std-conj-char))
  (assert nil () "Write me!"))

;;; ------------------------- Implementations -------------------------

;;; -  -  -  -  -  -  -  -  Hash-group  -  -  -  -  -  -  -  - 

(defclass hash-group (hash-set group-std-conj-char)
  ()
  (:documentation "A group whose underlying set is based on a hash-table.  It's a convenient implementation for smaller groups."))

(defgeneric make-group (x)
  (:documentation "Makes an mset from x as by make-set, then turns the result into a group.  The result will be a hash-group; thus this method is only for fairly small groups."))

(defmethod make-group ((table hash-table))
  (change-class (the hash-set (make-set table)) 'hash-group))

(defmethod make-group ((arg sequence))
  (change-class (the hash-set (make-set arg)) 'hash-group))

(defmethod make-group ((arg mset))
  (change-class (the hash-set (make-set arg)) 'hash-group))

(defmethod make-group ((single-elt t))
  (change-class (the hash-set (make-set single-elt)) 'hash-group))

;;; -  -  -  -  -  -  -  -  Lazy-group  -  -  -  -  -  -  -  - 

(defclass lazy-group (lazy-set group)
  ())

(defclass lazy-group-std-conj-char (lazy-set group-std-conj-char)
  ())

;;; -------------------- Basic functions --------------------

(defgeneric subgroup (pred gg)
  (:documentation "Same as (mset-subset pred gg), but returns a group, not just a set.  The user must guarantee that pred cuts out a subset satisfying the group axioms."))

(defmethod subgroup (pred (gg group))
  "The default method.  Returns a hash-group.  It's used if gg is a hash-group, but also if there's no other primary method."
  (make-group (mset-subset pred gg)))

(defmethod subgroup (pred (gg lazy-group))
  "Returns a lazy-group-std-conj-char.  This expresses the hope that the subgroup will be fairly small, even if gg isn't."
  (change-class (the lazy-set (mset-subset pred gg)) 'lazy-group-std-conj-char))

(defgeneric trivial-subgroup (gg)
  (:documentation "The subgroup of gg containing only 1."))

(defmethod trivial-subgroup ((gg group))
  (make-cyclic-group (identity-elt gg) 1 'exact))

(defmethod identity-elt ((gg group-std-conj-char))
  (if (cc-vec gg)
      (let ((g (conj-class-rep 0 gg)))
	(if (identityp g) ;; with the usual sorting, it will be
	    g
	  (identity-elt g))) ;; just in case
    (call-next-method)))

(defmethod identity-elt ((gg group))
  (identity-elt (mset-get-one-elt gg)))

(defgeneric order (a1 &optional a2 a3)
  (:documentation "Can be used in several ways.
[.] If the first argument is a group, the function returns
    its order, i.e., the number of its elements.  Like
    mset-size, it returns nil if the set is infinite or of
    unknown size.
[.] Otherwise, the first argument is a group-elt g, and the
    function returns its order, i.e., the least integer
    k > 0 such that g^k = 1.
    [.] If there is no second argument, we find the order
        of g using a linear search.
    [.] If the second argument is non-null, it should
        be some positive multiple n of the order of g.
        The second argument can also be a group G containing
        g, in which case we take n to be the order of G.
    [.] The third argument, if present, should be the prime
        factorization of n as returned by (factor n)."))

(defmethod order ((gg group) &optional a2 a3)
  (declare (ignore a2 a3))
  (mset-size gg))

(defmethod order ((g group-elt) &optional n-or-gg factor-n)
  (if (null n-or-gg)
      (do ((x g (mult x g)) ;; linear search
	   (e 1 (1+ e)))
	  ((identityp x) e)
	(declare (type (integer 1 *) e)))
    (cond ((typep n-or-gg 'group)
	   (order g (order n-or-gg) factor-n))
	  (t
	   (assert (typep n-or-gg '(integer 1 *)) (n-or-gg) "Second arg should be an integer >= 1, or a group, but was ~S." n-or-gg)
	   (let ((fac (or factor-n (factor n-or-gg)))
		 (e n-or-gg))
	     (declare (type (integer 1 *) e))
	     (dolist (pair fac e)
	       (destructuring-bind (p . v) pair
		 (declare (type (integer 2 *) p) (fixnum v))
		 (dotimes-f (i v)
		   (setf e (/ e p)))
		 (do ((g1 (power g e) (power g1 p)))
		     ((identityp g1))
		   (setf e (* e p))))))))))

(defmethod order ((g mod-1) &optional a2 a3)
  (declare (ignore a2 a3))
  (with-slots (value) g
    (declare (rational value))
    (denominator value)))

(defmethod order ((g direct-product-elt) &optional a2 a3)
  ;; Pedantic idea: if the factorization a3 is computed by the first
  ;; 'order', remember it and pass it to the second call.
  (with-slots (h k) g
    (lcm (order h a2 a3) (order k a2 a3))))

;; We have to sort the functions for commutativity so that we don't
;; get into loops.  The order is: check commutes-with on elements
;; directly, check conj-class sizes for group-std-conj-char, check
;; abelianp on the whole group, then any of centralizer and center and
;; commutator-subgroup.

(defgeneric abelianp (gg)
  (:documentation "Whether the group gg is abelian."))

(defmethod abelianp ((gg group))
  (do-mset (x gg t)
    (do-mset (y gg)
      (unless (commutes-with x y)
	(return-from abelianp nil)))))

(defmethod abelianp ((gg group-std-conj-char))
  (do-conj-class (c gg t)
    (unless (= (mset-size c) 1)
      (return nil))))

(defgeneric centralizer (g gg)
  (:documentation "Returns the centralizer of g in the group gg."))

(defmethod centralizer ((g group-elt) (gg group))
  (if (abelianp gg)
      gg
    (subgroup #'(lambda (h) (commutes-with g h)) gg)))

(defmethod centralizer ((g commuting-group-elt) (gg group))
  gg)

(defgeneric center (gg)
  (:documentation "Returns the center of the group gg."))

(defmethod center ((gg group))
  (if (abelianp gg)
      gg
    (subgroup #'(lambda (g)
		  (do-mset (h gg t)
		    (unless (commutes-with g h)
		      (return nil))))
	      gg)))
   
(defmethod center ((gg group-std-conj-char))
  (if (abelianp gg)
      gg
    (subgroup #'(lambda (g) (= (mset-size (conj-class g gg)) 1)) gg)))
   
(defgeneric commutator-subgroup (gg)
  (:documentation "Returns the commutator subgroup [gg, gg] of the group gg, as a hash-group."))

(defmethod commutator-subgroup ((gg group))
  (if (abelianp gg)
      (trivial-subgroup gg)
    (labels ((centralp (g)
	       (typecase g
		 (commuting-group-elt t)
		 (t (= (mset-size (conj-class g gg)) 1)))))
      (let ((ht (make-hash-table :test #'equalp)))
	(put-with-hash-key (identity-elt gg) ht)
	(do-mset (g gg)
	  (unless (centralp g)
	    (let ((g-inv (inverse g)))
	      (do-mset (h gg)
		(unless (centralp h)
		  (let ((comm (mult (conj-y-x-yinv h g g-inv) (inverse h))))
		    (put-with-hash-key comm ht)))))))
	(make-group ht)))))

(defgeneric sylow (p gg)
  (:documentation "Returns a p-Sylow subgroup of gg."))

(defmethod sylow :around ((p integer) (gg group))
  "Makes sure p is prime, and takes its absolute value if necessary.  Then dispatches to the primary method."
  (cond ((< p 0)
	 (sylow (- p) gg))
	(t
	 (assert (primep p) (p) "p = ~D is not prime." p)
	 (call-next-method))))    

(defgeneric simplep (gg)
  (:documentation "Whether this group is simple."))

(defgeneric generators (gg)
  (:documentation "Returns a list of group-elts that generate this group.  It may or may not be minimal set of generators.  The list may be empty if we don't know the generators."))

(defmethod generators ((gg group))
  "By default, return the empty list to mean we don't know."
  '())

(defmethod generators ((gg hash-group))
  "Dopey method that, for non-trivial groups, returns every element
besides the identity."
  (if (= (order gg) 1)
      (list (mset-get-one-elt gg))
    (let ((ans '()))
      (do-mset (g gg (nreverse ans))
	(unless (identityp g)
	  (push g ans))))))
    
(defgeneric exponent (gg)
  (:documentation "The exponent of the group gg, i.e., the smallest integer e such that g^e = 1 for all g in the group."))

(defmethod exponent ((gg group))
  "Slow default method."
  (let ((n (order gg))
	(ans 1))
    (let ((fac (factor n)))
      (do-mset (g gg ans)
	(setq ans (lcm ans (order g n fac)))
	(when (= ans n)
	  (return-from exponent ans))))))

(defmethod exponent ((gg group-std-conj-char))
  (let ((n (order gg))
	(ans 1))
    (let ((fac (factor n)))
      (do-conj-class-rep (g gg ans)
	(setq ans (lcm ans (order g n fac)))
	(when (= ans n)
	  (return-from exponent ans))))))

(defgeneric left-coset-reps (hh gg)
  (:documentation "Returns a list of representatives g for the left cosets g*hh of the subgroup hh of gg.  It is an error if hh is not a subgroup of gg.  We use a slow method for general gg which might be too big for all the elements to fit in a hash-table, in the hope that the index of hh in gg is small even if gg isn't."))

(defmethod left-coset-reps ((hh group) (gg group))
  (let ((g-list '())
	(g-inv-list '())) ;; inverses of what's in g-list
    (do-mset (x gg (nreverse g-list))
      (block test-x
	(dolist (g-inv g-inv-list)
	  (when (mset-member (mult g-inv x) hh)
	    (return-from test-x nil)))
	(push x g-list)
	(push (inverse x) g-inv-list)))))

(defmethod left-coset-reps ((hh group) (gg hash-group))
  (let ((ht-copy (make-hash-table :test #'equalp :size (order gg))))
    (maphash #'(lambda (k v) (puthash k v ht-copy)) (slot-value gg 'table))
    (left-coset-reps-small hh gg ht-copy)))

(defun left-coset-reps-small (hh gg &optional ht)
  "Implementation of (left-coset-reps hh gg) when gg is small enough that all its elements fit in a hash-table."
  (unless ht
    (setq ht (make-hash-table :test #'equalp :size (order gg)))
    (do-mset (g gg)
      (put-with-hash-key g ht)))
  (do ((ans '()))
      (nil)
    (block one-g
      (with-hash-table-iterator (get-one ht)
	(multiple-value-bind (exists g-k g) (get-one)
	  (declare (ignore g-k))
	  (cond (exists
		 (dolist (h hh)
		   (remhash (hash-key (mult g h)) ht))
		 (push g ans)
		 (return-from one-g nil))
		(t
		 (return-from left-coset-reps-small (nreverse ans)))))))))

;;; --------------- Class functions and Group characters ---------------

;;; As documented under gp-char, a class function on gg is a vector
;;; [simple-vector] of complexes, where the j-th entry is the value on
;;; gg's j-th conjugacy class.  We call a class function a gp-char
;;; when it lies in the Z-lattice generated by characters of
;;; representations.

(defmethod inner-product ((chi1 vector) (chi2 vector) (gg group))
  "Returns the Hermitian inner product
   (1/|G|) * Sum_(g in gg) chi1(g) * chi2(g)^conjugate
on the space of class functions on the group gg.  If chi1 and chi2 are characters or virtual characters on gg, use gp-char-inner-product."
  (let ((ans 0))
    (dotimes (j (conj-class-num gg) (/ ans (order gg)))
      (incf ans (* (mset-size (conj-class j gg))
		   (svref chi1 j)
		   (conjugate (svref chi2 j)))))))

(defun gp-char-inner-product (chi1 chi2 gg)
  "Same as inner-product, but assumes the chi's are characters [or virtual characters] of representations, so that the result will lie in Z.  It rounds off the result to an integer."
  (round (realpart (inner-product chi1 chi2 gg))))

(defun norm-sq (chi gg)
  "Returns the inner product of chi with itself, where chi is a class function on gg.  If chi is a character or virtual character on gg, use gp-char-norm-sq."
  (inner-product chi chi gg))

(defun gp-char-norm-sq (chi gg)
  "Same as norm-sq, but assumes chi is a character [or virtual character] of a representation, so that the result will lie in Z.  It rounds off the result to an integer."
  (round (realpart (norm-sq chi gg))))

(defun make-gp-char-trivial (gg)
  "Returns the trivial character on the group gg."
  (make-array (conj-class-num gg) :initial-element 1))

(defun make-gp-char-regular (gg)
  "Returns the character of the regular representation on the group gg."
  (let ((chi (make-array (conj-class-num gg) :initial-element 0)))
    (setf (aref chi (conj-class-index (identity-elt gg) gg)) (order gg))
    chi))

(defun make-gp-char-zero (gg)
  "Returns the zero character on the group gg."
  ;; Should say, the zero virtual character.  :->
  (make-array (conj-class-num gg) :initial-element 0))

(defun gp-char-add (chi1 chi2)
  "Returns chi1 + chi2."
  (map 'vector #'+ chi1 chi2))

(defun gp-char-subtract (chi1 chi2)
  "Returns chi1 - chi2."
  (map 'vector #'- chi1 chi2))

(defgeneric gp-char-mult (x chi2)
  (:documentation " (gp-char-mult n chi2) returns the scalar n times chi2.
 (gp-char-mult chi1 chi2) returns the pointwise product chi1 * chi2, corresponding to the tensor product of representations."))

(defmethod gp-char-mult ((n number) (chi2 vector))
  (map 'vector #'(lambda (c) (* n c)) chi2))

(defmethod gp-char-mult ((n (eql 1)) (chi2 vector))
  chi2)

(defmethod gp-char-mult ((chi1 vector) (chi2 vector))
  (map 'vector #'* chi1 chi2))

(defun gp-char-conjugate (chi)
  "Returns the complex conjugate of chi, corresponding to the dual of a representation."
  (map 'vector #'conjugate chi))

(defun gp-char-irredp (chi gg)
  "Is the gp-char chi the character of an irreducible representation [and similarly for virtual characters]?"
  (= 1 (gp-char-norm-sq chi gg)))

(defun gp-char-zerop (chi gg)
  "Is the gp-char chi the zero character?"
  (zerop (gp-char-norm-sq chi gg)))

(defun gp-char-equal (chi1 chi2 gg)
  "Are chi1 and chi2 equal as gp-chars?"
  (gp-char-zerop (gp-char-subtract chi1 chi2) gg))

(defun gp-char-degree (chi gg)
  "Returns the degree of the representation associated to the gp-char chi on the group gg."
  (round (realpart (gp-char-value chi (identity-elt gg) gg))))

(defgeneric gp-char-kernel (chi gg)
  (:documentation "Returns the subgroup of gg that maps to the identity under the representation associated to chi."))

(defmethod gp-char-kernel ((chi vector) (gg group))
  "Default method that returns a hash-group."
  (let ((k (exponent gg))
	(table (make-hash-table :test #'equalp)))
    (when (= 1 (mod k 2))
      (setq k (* 2 k)))
    (let ((cos2n (cos (/ pi k)))) ;; 2*pi / 2*k
      (let ((cutoff (- (gp-char-degree chi gg) (- 1 cos2n))))
	(dotimes (j (conj-class-num gg) (make-group table))
	  (when (> (realpart (gp-char-value chi j)) cutoff)
	    (do-mset (g (conj-class j gg))
	      (put-with-hash-key g table))))))))

(defun gp-char-real-type (chi gg)
  "Let chi be the character of a representation rho of gg over the complex numbers.  This function returns 1 if is *real*, i.e., is a real representation tensored with C.  It returns -1 if rho is *quaternionic*, i.e., has a gg-invariant conjugate-linear automorphism J with J^2 = -I.  It returns 0 otherwise, meaning rho is *complex*."
  (let ((ans 0))
    (dotimes (j (conj-class-num gg) (round (/ ans (order gg))))
      (let ((g (conj-class-rep j gg)))
	(incf ans (* (gp-char-value chi (mult g g) gg)
		     (mset-size (conj-class j gg))))))))

(defun gp-char-wedge2 (chi gg)
  (let* ((h (conj-class-num gg))
	 (ans (make-array h :element-type 'complex)))
    (dotimes (j h ans)
      (let ((g (conj-class-rep j gg))
	    (chi-g (gp-char-value chi j gg)))
	(let ((chi--g-sq (gp-char-value chi (mult g g) gg))
	      (chi-g--sq (* chi-g chi-g)))
	  (setf (svref ans j)
	    (/ (- chi-g--sq chi--g-sq) 2)))))))

(defun gp-char-sym2 (chi gg)
  (let* ((h (conj-class-num gg))
	 (ans (make-array h :element-type 'complex)))
    (dotimes (j h ans)
      (let ((g (conj-class-rep j gg))
	    (chi-g (gp-char-value chi j gg)))
	(let ((chi--g-sq (gp-char-value chi (mult g g) gg))
	      (chi-g--sq (* chi-g chi-g)))
	  (setf (svref ans j)
	    (/ (+ chi-g--sq chi--g-sq) 2)))))))

;;; -------------------- cyclic-group --------------------

(defclass cyclic-group (group)
  ((elts :initarg :elts
	 :type vector
	 :documentation "The elements, in the order 1, g, g^2, ...")
   (elt-to-i :initarg :elt-to-i
	     :type hash-table
	     :documentation "Maps (hash-key elt) to i where elt = g^i, with g being the fixed generator (svref elts 1)."))
  (:documentation "A finite cyclic group."))

(defmethod mset-iterator ((gg cyclic-group))
  (with-slots (elts) gg
    (let ((n (length elts))
	  (i 0))
      #'(lambda ()
	  (if (< i n)
	      (prog1 (svref elts i) (incf i))
	    nil)))))

(defmethod mset-member (elt (gg cyclic-group))
  (has-key (hash-key elt) (slot-value gg 'elt-to-i)))

(defmethod mset-size ((gg cyclic-group))
  (length (slot-value gg 'elts)))

(defgeneric make-cyclic-group (x &optional a2 a3)
  (:documentation "If x = n is a positive integer, creates a cyclic group of order n generated by the mod-1 with value 1/n.  If x is a group-elt, creates the cyclic group generated by x.  In this latter case, the optional arguments are the same as for (order x a2 a3).  However, if a3 is the symbol EXACT, then a2 is assumed to be exactly the order of x."))

(defmethod make-cyclic-group ((n integer) &optional a2 a3)
  (declare (ignore a2 a3))
  (assert (>= n 1) (n) "Order of a cyclic group must be >= 1, not ~D." n)
  (make-cyclic-group (make-mod-1 (/ 1 n)) n 'exact))

(defmethod make-cyclic-group ((g group-elt) &optional a2 a3)
  (let ((n (if (eq a3 'exact) a2 (order g a2 a3))))
    (declare (type (integer 1 *) n))
    (let ((v (make-array n :element-type 'group-elt))
	  (h (make-hash-table :test #'equalp :size n)))
      (do ((g0 (identity-elt g) (mult g0 g))
	   (i 0 (1+ i)))
	  ((= i n))
	(setf (svref v i) g0)
	(puthash (hash-key g0) i h))
      (make-instance 'cyclic-group :elts v :elt-to-i h))))

(defmethod generators ((gg cyclic-group))
  "For a cyclic group, returns a list holding the standard generator."
  (with-slots (elts) gg
    (list (svref elts (if (> (length elts) 1) 1 0)))))

(defmethod conj-class-num ((gg cyclic-group))
  (order gg))

(defmethod conj-class ((j integer) (gg cyclic-group))
  (make-set (conj-class-rep j gg)))

(defmethod conj-class-index ((g group-elt) (gg cyclic-group))
  (gethash (hash-key g) (slot-value gg 'elt-to-i)))

(defmethod conj-class-rep ((j integer) (gg cyclic-group))
  (svref (slot-value gg 'elts) j))

(defmethod gp-char ((i integer) (gg cyclic-group))
  (let* ((n (order gg))
	 (chi (make-array n :element-type 'complex)))
    (dotimes (j n chi)
      (setf (svref chi j) (cis-2pi (/ (* i j) n))))))

(defmethod gp-char ((i (eql 0)) (gg cyclic-group))
  (make-array (order gg) :initial-element 1))

(defun cis-2pi (x)
  "Computes cis of 2*pi*x for rational x, returning exact values in a few cases for rational x."
  (declare (rational x))
  (let ((x1 (mod x 1)))
    (declare (rational x1))
    (case x1
      (0 1)
      (1/2 -1)
      (1/4 (complex 0 1))
      (3/4 (complex 0 -1))
      (t (cis (* x1 2 pi))))))

(defmethod identity-elt ((gg cyclic-group))
  (svref (slot-value gg 'elts) 0))

(defmethod abelianp ((gg cyclic-group))
  t)

(defun subgroup-of-index (index gg)
  "Returns the subgroup of given index in the cyclic group gg."
  (declare (integer index) (type cyclic-group gg))
  (assert (>= index 1) (index)
    "The index ~S must be an integer >= 1." index)
  (if (= index 1)
      gg
    (let* ((n (order gg))
	   (n1 (/ n index))) ;; order of the result
      (assert (integerp n1) ()
	"The index ~D does not divide the order ~D of the cyclic group."
	index n)
      (let ((v1 (make-array n1 :element-type 'group-elt))
	    (h1 (make-hash-table :test #'equalp :size n1)))
	(with-slots ((v elts) (h elt-to-i)) gg
	  (do ((i 0 (1+ i))
	       (j 0 (+ j index)))
	      ((= i n1))
	    (declare (integer i j))
	    (setf (svref v1 i) (svref v j))
	    (puthash (hash-key (svref v j)) i h1))
	  (make-instance 'cyclic-group :elts v1 :elt-to-i h1))))))

(defmethod subgroup (pred (gg cyclic-group))
  "Returns a cyclic-group."
  (let ((n (order gg)))
    (declare (integer n))
    (with-slots ((v elts)) gg
      (do ((i 1 (1+ i)))
	  ((= i n))
	(declare (integer i))
	(when (funcall pred (svref v i))
	  (return-from subgroup (subgroup-of-index i gg))))
      (subgroup-of-index n gg))))

(defmethod sylow ((p integer) (gg cyclic-group))
  (labels ((divide-out-ps (k p)
	     (declare (integer k p))
	     (multiple-value-bind (q r) (floor k p)
	       (declare (integer q r))
	       (if (zerop r) (divide-out-ps q p) k))))
    (subgroup-of-index (divide-out-ps (order gg) p) gg)))    

(defmethod simplep ((gg cyclic-group))
  (primep (order gg)))

(defmethod exponent ((gg cyclic-group))
  (order gg))

(defmethod gp-char-kernel ((chi vector) (gg cyclic-group))
  (let ((prod-with-1 (round (/ (realpart (reduce #'+ chi)) (order gg))))
	(degree (round (realpart (svref (slot-value gg 'elts) 0)))))
    (if (= degree prod-with-1) ;; chi is a direct sum of trivial chars
	gg
      (trivial-subgroup gg))))

(defmethod print-object ((gg cyclic-group) s)
  (format s "#<C_~D ~S>" (order gg) (car (generators gg))))

;;; ----- The next few were from util.lisp before we moved to shh2. -----

(defun iota (n &optional (ans '()))
  "Returns the list of integers from 0 [inclusive] to n [exclusive]."
  (declare (integer n))
  (if (< n 0)
      ans
    (let ((n1 (1- n)))
      (iota n1 (cons n1 ans)))))

(defun row-major-helper (dims)
  "Input: dims, a list of non-negative integers, thought of as (array-dimensions A) for some array A.  Output: the helper list for array-index-row-major [q.v.]  If A is of rank 0, the special symbol rank-0 is returned instead."
  (if (null dims)
      'rank-0
    (labels ((f (dims ans)
	       (if (null dims)
		   ans
		 (f (cdr dims) (cons (* (car dims) (car ans)) ans)))))
      (f (reverse (cdr dims)) '()))))
  
(defun array-index-row-major (index helper &optional (ans '()))
  "Assume we have some array A.  'index' is a row-major index for A.  'helper' is as computed by (row-major-helper (array-dimensions A)).  The output is the list of indices for the entry of A corresponding to 'index'."
  (declare (fixnum index))
  (if (eq helper 'rank-0)
      '()
    (if (null helper)
	(nreverse (cons index ans))
      (multiple-value-bind (q r) (floor index (the fixnum (car helper)))
	(array-index-row-major r (cdr helper) (cons q ans))))))

;;; -------------------- Abelian-group --------------------

(defclass abelian-group (group)
  ((elts :initarg :elts
	 :type array
	 :documentation "The elements, in order by Smith normal form.")
   (elts-to-inds :initarg :elt-to-inds
		 :type hash-table
		 :documentation "Maps (hash-key elt) to the list of its indices in elts.")
   (row-major-helper :initarg :row-major-helper
		     :type list
		     :documentation "Caches (row-major-helper (array-dimensions elts))."))
  (:documentation "Provides extra structures for abelian groups that are small enough so the elements can be stored all at once.  An abelian group does not have to be implemented as an abelian-group, but tools like character tables expect them to be.  The function make-abelian-group converts a given abelian group into an abelian-group with the same elements."))

(defun make-abelian-group (gg)
  "Converts the group gg into an abelian-group object with the same elements.  It's an error if the group is not actually abelian, i.e., if some elements don't commute."
  (assert (typep gg 'group) (gg) "The argument ~S must be a group." gg)
  (let ((n (order gg)))
    (let ((fac (factor n))
	  (cg-list '()) ;; accumulates C_n's for SNF generators
	  (prod (list (identity-elt gg))) ;; accum's prod's from cg-list so far
	  (unused (make-hash-table :test #'equalp :size n))) ;; G - prod
      (do-mset (g gg)
	(unless (identityp g)
	  (put-with-hash-key g unused)))
      (do ()
	  ((zerop (hash-table-count unused)))
	(let ((index-prod (/ n (length prod)))
	      (trial-list '()))
	  ;; trial-list holds all elements of unused whose order
	  ;; divides index-prod.  It's sorted with bigger orders
	  ;; first.
	  (maphash #'(lambda (g-k g)
		       (declare (ignore g-k))
		       (when (zerop (mod index-prod (order g n fac)))
			 (push g trial-list)))
		   unused)
	  (setq trial-list
	    (sort trial-list #'(lambda (g1 g2)
				 (> (order g1 n fac) (order g2 n fac)))))
	  (let ((prod1 (make-hash-table :test #'equalp))
		(cg nil)
		(next-gen nil))
	    ;; For each trial g, prod1 holds all products in prod * <g>.
	    (block got-g
	      (dolist (g trial-list)
		(block try-g
		  (setq cg (make-cyclic-group g))
		  ;; Check if prod and cg meet only in 1.
		  (dolist (p prod)
		    (when (and (mset-member p cg) (not (identityp p)))
		      (return-from try-g nil)))
		  ;; Check if all products in prod * <g> are distinct.
		  (clrhash prod1)
		  (dolist (p prod)
		    (do-mset (h cg)
		      (let* ((ph (mult p h))
			     (ph-k (hash-key ph)))
			(if (has-key ph-k prod1)
			    (return-from try-g nil)
			  (puthash ph-k ph prod1)))))
		  (setq next-gen g)
		  (return-from got-g nil))))
	    (assert next-gen () "Trouble constructing snf.")
	    (setq prod '())
	    (maphash #'(lambda (p-k p)
			 (push p prod)
			 (remhash p-k unused))
		     prod1)
	    (push cg cg-list))))
      (setq cg-list (nreverse cg-list))
      (when (null cg-list) ;; gg = {1}
	(push (make-cyclic-group (identity-elt gg)) cg-list))
      ;; At this point, cg-list holds a set of cyclic-groups giving
      ;; the Smith normal form, with higher-order elements first.
      (let ((dims (mapcar #'order cg-list)))
	(let ((ee (make-array dims :element-type 'group-elt))
	      (ei (make-hash-table :test #'equalp :size n))
	      (helper (row-major-helper dims))
	      (id (identity-elt gg)))
	  (dotimes (i n)
	    (let ((inds (array-index-row-major i helper)))
	      (do ((ii inds (cdr ii))
		   (cgs cg-list (cdr cgs))
		   (p id (mult p (svref (slot-value (car cgs) 'elts) (car ii)))))
		  ((null ii)
		   (setf (svref ee i) p)
		   (puthash (hash-key p) inds ei)))))
	  (make-instance 'abelian-group :elts ee :elts-to-inds ei :row-major-helper helper))))))

(defmethod mset-iterator ((gg abelian-group))
  (let ((n (order gg))
	(i 0))
    #'(lambda ()
	(if (< i n)
	    (prog1 (row-major-aref (slot-value gg 'elts) i) (incf i))
	  nil))))

(defmethod mset-member ((g group-elt) (gg abelian-group))
  (has-key (hash-key g) (slot-value gg 'elts-to-inds)))

(defmethod mset-size ((gg abelian-group))
  (array-total-size (slot-value gg 'elts)))

(defmethod abelianp ((gg abelian-group))
  t)
    
(defmethod conj-class-num ((gg abelian-group))
  (order gg))

(defmethod conj-class ((j integer) (gg abelian-group))
  (make-set (conj-class-rep j gg)))

(defmethod conj-class-rep ((j integer) (gg abelian-group))
  (row-major-aref (slot-value gg 'elt) j))

(defmethod conj-class-index ((g group-elt) (gg abelian-group))
  (with-slots (elts elts-to-inds) gg
    (let ((inds (gethash (hash-key g) elts-to-inds)))
      (apply #'array-row-major-index elts inds))))

(defmethod exponent ((gg abelian-group))
  (array-dimension (slot-value gg 'elts) 0))

(defmethod generators ((gg abelian-group))
  (if (= 1 (order gg))
      (list (identity-elt gg))
    (with-slots (elts) gg
      (let* ((rk (array-rank elts))
	     (iota-v (iota rk)))
	(mapcar #'(lambda (ijk) (apply #'aref elts ijk))
		(mapcar #'(lambda (i)
			    (mapcar #'(lambda (j) (if (= j i) 1 0))
				    iota-v))
			iota-v))))))

(defmethod gp-char ((i integer) (gg abelian-group))
  (with-slots (elts elts-to-inds helper) gg
    (let ((n (array-total-size elts)) ;; order
	  (dims (array-dimensions elts))
	  (inds-chi (array-index-row-major i helper)))
      (let ((chi (make-array n :element-type 'complex)))
	(dotimes (j n chi)
	  (let ((g (row-major-aref elts j)))
	    (do ((i-chi inds-chi (cdr i-chi))
		 (i-g (gethash (hash-key g) elts-to-inds) (cdr i-g))
		 (i-d dims (cdr i-d))
		 (x 0 (+ (/ (* (car i-chi) (car i-g)) (car i-d)) x)))
		((null i-chi)
		 (setf (svref chi j) (cis-2pi x)))
	      (declare (rational x)))))))))

(defmethod gp-char ((i (eql 0)) (gg abelian-group))
  (make-array (order gg) :initial-element 1))

(defmethod gp-char-kernel ((chi vector) (gg abelian-group))
  (make-abelian-group (call-next-method)))

(defmethod identity-elt ((gg abelian-group))
  (row-major-aref (slot-value gg 'elts) 0))

(defmethod simplep ((gg abelian-group))
  (with-slots (elts) gg
    (and (= 1 (array-rank elts))
	 (primep (array-dimension elts 0)))))

(defmethod subgroup (pred (gg abelian-group))
  (make-abelian-group (call-next-method pred gg)))

(defmethod sylow ((p integer) (gg abelian-group))
  (let ((n (order gg)))
    (let ((fac (factor n))
	  (m 0)
	  (ans-ord 1))
      (dolist (pe fac)
	(when (= p (car pe))
	  (setq m (cdr pe))
	  (setq ans-ord (power p m))
	  (return nil)))
      (let ((ans (make-hash-table :test #'equalp :size ans-ord)))
	(do-mset (g gg)
	  (when (is-power-of (order g n fac) p)
	    (put-with-hash-key g ans)
	    (when (= (hash-table-count ans) ans-ord)
	      (return nil))))
	(make-p-group ans p m)))))

;;; -------------------- p-group --------------------

(defclass p-group (hash-group)
  ((p :type (integer 2 *)
      :documentation "The order of the group is p^m.")
   (m :type (integer 0 *)
      :documentation "The order of the group is p^m."))
  (:documentation "A group of order p^m, where p is a prime and m is greater than or equal to 0.  A group of prime power order does not have to be implemented as a p-group, but tools like character tables assume it will be.  make-p-group makes it easy to convert a given group of order p^m into a p-group with the same elements."))

(defun make-p-group (gg &optional p m)
  "Converts the contents of gg into a p-group object with the same elements.  It's an error if the group is not actually of prime power order.  gg can be like any of the arguments to make-set, notably an equalp hash-table or a group."
  (let ((ans (make-group gg))) ;; put the elements into a new hash-group
    (cond ((not (and p m))
	   (let ((fac (factor (mset-size gg))))
	     (assert (= 1 (length fac)) ()
	       "The order ~D is not a prime power." (mset-size gg))
	     (setq p (caar fac) m (cdar fac))))
	  (t
	   (assert (primep p) (p) "~D is not prime." p)
	   (when (< p 0) (setq p (- p)))
	   (assert (= (power p m) (mset-size gg)) ()
	     "~D^~D = ~D is not the size ~D of gg."
	     p m (power p m) (mset-size gg))))
    (change-class ans 'p-group)
    (setf (slot-value ans 'p) p)
    (setf (slot-value ans 'm) m)
    ans))

(defmethod center ((gg p-group))
  (make-p-group (call-next-method)))

(defmethod centralizer ((g group-elt) (gg p-group))
  (make-p-group (call-next-method)))

(defmethod commutator-subgroup ((gg p-group))
  (make-p-group (call-next-method)))

(defmethod fill-in-char-table ((gg p-group))
  (assert nil () "Write me!"))

(defmethod gp-char-kernel ((chi vector) (gg p-group))
  (make-p-group (call-next-method)))

(defmethod simplep ((gg p-group))
  (= 1 (slot-value gg 'm)))

(defmethod subgroup (pred (gg p-group))
  (make-p-group (call-next-method pred gg)))

(defmethod sylow ((p0 integer) (gg p-group))
  (if (= p0 (slot-value gg 'p))
      gg
    (trivial-subgroup gg)))

;;; -------------------- Semidirect and direct products --------------------

;;; G = H x| K, where x| is the symbol

;;; \  /|
;;;  \/ |
;;;  /\ |
;;; /  \|

;;; Example: the dihedral group of order 2n is C_n x| C_2 with
;;; action = #'(lambda (k1 h2) (if (identityp k1) h2 (inverse h2))).

;;; Example: if G is given and H, K are subgroups with H normal, then
;;; action = #'(lambda (k1 h2) (conj-y-x-yinv h2 k1)).

(defclass semidirect-product (group)
  ((hh :reader factor1
       :initarg :hh
       :type group)
   (kk :reader factor2
       :initarg :kk
       :type group)
   (action :reader sd-action
	   :initarg :action
	   :type function))
  (:documentation "The semidirect product hh x| kk.  See also factor1, factor2."))

(defun make-semidirect-product (hh kk action)
  "Returns the semidirect-product group hh x| kk with the given action of kk on hh.  The action takes arguments (k1 h2), meaning k1 acts on hh by an automorphism sigma_k1.  The return value for action is sigma_k1(h2).  See also factor1, factor2."
  (declare (type group hh kk) (function action))
  (make-instance 'semidirect-product :hh hh :kk kk :action action))

(defmethod mset-iterator ((gg semidirect-product))
  (with-slots (hh kk action) gg
    (let ((prod-iter (mset-product-iterator hh kk)))
      #'(lambda ()
	  (aif (funcall prod-iter)
	       (make-instance 'semidirect-product-elt
		 :h (first it) :k (second it) :action action)
	       nil)))))

(defmethod mset-member (g (gg semidirect-product))
  (when (typep g 'semidirect-product-elt)
    (with-slots (h k) g
      (with-slots (hh kk) gg
	(and (mset-member h hh) (mset-member k kk))))))

(defmethod mset-size ((gg semidirect-product))
  (with-slots (hh kk) gg
    (let ((hhn (order hh)))
      (when hhn
	(let ((kkn (order kk)))
	  (when kkn
	    (* hhn kkn)))))))

(defmethod simplep ((gg semidirect-product))
  (with-slots (hh kk) gg
    (cond ((= (order hh) 1) (simplep kk))
	  ((= (order kk) 1) (simplep hh))
	  (t nil))))

(defmethod generators ((gg semidirect-product))
  (let ((gen1 (generators (factor1 gg))))
    (if (null gen1)
	'()
      (let ((gen2 (generators (factor2 gg))))
	(if (null gen2)
	    '()
	  (mapcan
	   (let ((id2 (identity-elt (factor2 gg))))
	     (mapcar #'(lambda (g1)
			 (make-semidirect-product-elt g1 id2 (sd-action gg)))
			 gen1))
	   (let ((id1 (identity-elt (factor1 gg))))
	     (mapcar #'(lambda (g2)
			 (make-semidirect-product-elt id1 g2 (sd-action gg)))
		     gen2))))))))

(defmethod identity-elt ((gg semidirect-product))
  (make-semidirect-product-elt (identity-elt (factor1 gg))
			       (identity-elt (factor2 gg))
			       (sd-action gg)))

(defclass direct-product (semidirect-product)
  ()
  (:documentation "A semidirect-product where the action is trivial."))

(defun make-direct-product (hh kk)
  "Makes a direct product of two groups.  See also factor1, factor2."
  (change-class (make-semidirect-product hh kk *trivial-action*)
		'direct-product))

(defmethod abelianp ((gg direct-product))
  (and (abelianp (factor1 gg)) (abelianp (factor2 gg))))

(defmethod center ((gg direct-product))
  (make-direct-product (center (factor1 gg)) (center (factor2 gg))))

(defmethod centralizer ((g direct-product-elt) (gg direct-product))
  (make-direct-product (centralizer (factor1 g) (factor1 gg))
		       (centralizer (factor2 g) (factor2 gg))))

(defmethod commutator-subgroup ((gg direct-product))
  (make-direct-product (commutator-subgroup (factor1 gg))
		       (commutator-subgroup (factor2 gg))))

(defmethod conj-class-num ((gg direct-product))
  (* (conj-class-num (factor1 gg)) (conj-class-num (factor2 gg))))

(defmethod conj-class-index ((g direct-product-elt) (gg direct-product))
  (+ (conj-class-index (factor1 g) (factor1 gg))
     (* (conj-class-index (factor2 g) (factor2 gg))
	(conj-class-num (factor1 gg)))))

(defmethod conj-class ((j integer) (gg direct-product))
  (multiple-value-bind (q r) (floor j (conj-class-num (factor1 gg)))
    (let ((c1 (conj-class r (factor1 gg)))
	  (c2 (conj-class q (factor2 gg)))
	  (ans (make-instance 'lazy-set)))
      (setf (slot-value ans 'itererator-factory)
	#'(lambda ()
	    (let ((prod-iter (mset-product-iterator c1 c2)))
	      #'(lambda ()
		  (aif (funcall prod-iter)
		       (make-direct-product-elt (first it) (second it))
		    nil)))))
      (setf (slot-value ans 'containment-test)
	#'(lambda (g)
	    (and (mset-member (factor1 g) c1)
		 (mset-member (factor2 g) c2))))
      (setf (slot-value ans 'size)
	(* (mset-size c1) (mset-size c2)))
      ans)))

(defmethod identity-elt ((gg direct-product))
  (make-direct-product-elt (identity-elt (factor1 gg))
			   (identity-elt (factor2 gg))))

(defmethod exponent ((gg direct-product))
  (lcm (exponent (factor1 gg)) (exponent (factor2 gg))))

;;; -------------------- Dihedral group --------------------

(defclass dihedral-group (semidirect-product group-std-conj-char)
  ()
  (:documentation "The dihedral group.  A straightforward implementation as the semidirect product C_n x| C_2."))

(defun make-dihedral-group (n)
  "Creates a dihedral-group of order 2n."
  (assert (and (integerp n) (>= n 1)) (n) "Need n >= 1, not ~S." n)
  (let ((hh (make-cyclic-group n))
	(kk (make-cyclic-group 2)))
    (change-class
     (make-semidirect-product
      hh kk #'(lambda (k1 h2) (if (identityp k1) h2 (inverse h2))))
     'dihedral-group)))

;;; -------------------- Bigger functions --------------------

;;; The full Sylow code.
;;; The general character table code.

;;; ------------------------- Unit tests -------------------------

(let ((c7 (make-mod-1 7/12))
      (clock (make-cyclic-group 12)))
  (macrolet ((val (mod-1-elt)
	       `(the rational (slot-value ,mod-1-elt 'value))))
    (labels ((implies (a b) (if a b t))
	     (iff (a b) (if a b (not b))))
      (assert (= (val c7) 7/12))
      (assert (equalp (print-object c7 nil) "#<7/12 mod 1>"))
      (assert (= (val (mult c7 c7)) 1/6))
      (assert (= (val (mult c7 c7 c7)) 3/4))
      (assert (= (val (mult c7 c7 c7 c7)) 1/3))
      (assert (= (val (inverse c7)) 5/12))
      (assert (= (val (identity-elt c7)) 0))
      (assert (identityp (identity-elt c7)))
      (assert (not (identityp c7)))
      (assert (= (order c7) 12))
      (dotimes-f (i 20)
	(assert (= (order (power c7 i) 12 '((2 . 2) (3 . 1)))
		   (/ 12 (gcd i 12)))))
      (assert (= (val (power c7 6)) 1/2))
      (assert (group-elt-equal (power c7 4) (mult c7 c7 c7 c7)))
      (assert (group-elt-equal (power c7 11) (inverse c7)))
      (assert (commutes-with c7 c7))
      (assert (group-elt-equal (conj-y-x-yinv c7 c7) c7))
      (assert (group-elt-equal (conj-yinv-x-y c7 c7) c7))
      (assert (mset-equal (centralizer c7 clock) clock))
      (assert (= 12 (order (center clock))))
      (assert (= (order clock) 12))
      (assert (= (order c7 clock) 12))
      (assert (mset-member c7 clock))
      (let ((i 0))
	(do-mset (x clock)
	  (assert (iff (group-elt-equal x c7) (= i 7)))
	  (incf i)))
      (assert (= 12 (conj-class-num clock)))
      (assert (= 7 (conj-class-index c7 clock)))
      (assert (group-elt-equal c7 (conj-class-rep c7 clock)))
      (let ((i 0))
	(do-conj-class (class-i clock)
	  (assert (= 1 (mset-size class-i)))
	  (assert (iff (group-elt-equal c7 (mset-get-one-elt class-i))
		       (= i 7)))
	  (incf i)))
      (assert (mset-equal (commutator-subgroup clock)
			  (trivial-subgroup clock)))
      (assert (mset-equal
	       (subgroup #'(lambda (g) (integerp (* 2 (val g)))) clock)
	       (make-cyclic-group 2)))
      (assert (mset-equal (sylow 2 clock) (make-cyclic-group 4)))
      (assert (mset-equal (sylow 3 clock) (make-cyclic-group 3)))
      (do-mset (p *primes*)
	(assert (implies (>= p 5)
			 (mset-equal (sylow p clock)
				     (trivial-subgroup clock))))
	(when (> p 15) (return)))
      (assert (abelianp clock))
      (assert (not (simplep clock)))
      (assert (= (exponent clock) 12))
      (assert (simplep (make-cyclic-group 11))))))

(let ((dsq (make-dihedral-group 4)))
  (assert (= 8 (order dsq)))
  (assert (not (abelianp dsq)))
  (assert (= 5 (conj-class-num dsq)))
  (dotimes (i 5)
    (assert (= (mset-size (conj-class i dsq))
	       (nth i '(1 1 2 2 2)))))
  (let ((ctr (center dsq))
	(r2 nil)) ;; will be set to R^2
    (assert (= 2 (order ctr)))
    (do-mset (g ctr)
      (assert (group-elt-equal g (conj-class-rep g dsq)))
      (assert (mset-equal (centralizer g dsq) dsq))
      (cond ((identityp g)
	     (assert (= 0 (conj-class-index g dsq))))
	    (t
	     (setq r2 g)
	     (assert (= 1 (conj-class-index r2 dsq)))
	     (assert (= 2 (order r2)))
	     (assert (= 2 (order (factor1 r2))))
	     (assert (= 1 (order (factor2 r2)))))))
    (assert (not (null r2)))
    (let ((r-ct 0)
	  (re-ct 0))
      (do-conj-class (c dsq)
	(when (= (mset-size c) 2)
	  (let* ((iter (mset-iterator c))
		 (x (funcall iter))
		 (y (funcall iter)))
	    (cond ((identityp (factor2 x))
		   ;; {x, y} = {R, R^3}
		   (assert (= 4 (order x)))
		   (assert (= 4 (order (factor1 x))))
		   (assert (group-elt-equal (mult x x) r2))
		   (assert (identityp (factor2 y)))
		   (assert (= 4 (order y)))
		   (assert (= 4 (order (factor1 y))))
		   (assert (group-elt-equal (mult y y) r2))
		   (assert (group-elt-equal y (inverse x)))
		   (assert (group-elt-equal x (inverse y)))
		   (assert (group-elt-equal y (power x 3)))
		   (assert (group-elt-equal x (power y 3)))
		   (assert (identityp (mult x y)))
		   (assert (commutes-with x y))
		   (assert (commutes-with x r2))
		   (assert (commutes-with y r2))
		   (assert (mset-equal (centralizer x dsq) (mset-union ctr c)))
		   (assert (mset-equal (centralizer y dsq) (mset-union ctr c)))
		   (incf r-ct))
		  (t
		   ;; {x, y} = {R^i*E, R^(i+2)*E}
		   (assert (= 2 (order x)))
		   (assert (= 2 (order y)))
		   (assert (group-elt-equal x (inverse x)))
		   (assert (group-elt-equal y (inverse y)))
		   (assert (= 2 (order (factor2 x))))
		   (assert (= 2 (order (factor2 y))))
		   (assert (group-elt-equal (mult x y) r2))
		   (assert (group-elt-equal (mult y x) r2))
		   (assert (commutes-with x y))
		   (assert (group-elt-equal x (conj-y-x-yinv x y)))
		   (assert (group-elt-equal x (conj-yinv-x-y x y)))
		   (assert (mset-equal (centralizer x dsq) (mset-union ctr c)))
		   (assert (mset-equal (centralizer y dsq) (mset-union ctr c)))
		   (incf re-ct))))))
      (assert (= r-ct 1))
      (assert (= re-ct 2)))
    (assert (= 1 (order (trivial-subgroup dsq))))
    (assert (mset-equal (commutator-subgroup dsq) ctr))
    (assert (= (exponent dsq) 4))
    ;; Other ideas:
    ;; --Extract the C_4 subgroup and show it's {1,a,a^2,a^3}
    ;; where a is one of R or R^3.
    ;; -- (generators ...) should work, if it does for cyclics.
    ;; Explicitly test the conj classes in terms of the generators.
    ))

;;; ------------------------- TO DO -------------------------

;;; Fix bug with S_1, A_2, SL_1, PSL_1, GL_1(2), PGL_1, or whenever
;;; Pari hangs with Gram matrix [1].

;;; Speed up getCompositionSeries, getProperNormalSubgroup, and
;;; isSimple.  Why is it so slow on PSL_2(7)?  Have special versions
;;; for groups of prime order, abelian groups (using SNF), C_n's.

;;; Add GpCharacter's wedge^k and Sym^k as in Serre, Ch. 9.  Each has
;;; two versions, e.g., wedge(k) to return just wedge^k, and
;;; wedgeUpTo(k) returning a List of wedge^0, ..., wedge^k.

;;; Find H^2(G,A) for given G, A, and action, with applications both to
;;; constructing groups and to number theory.

;;; Define an interface Automorphism extending GroupElt.  Classes
;;; implementing Automorphism guarantee that source = target, the map
;;; is an isomorphism, and the group operations are well defined.

;;; Find Aut(G) for given G, including the decompositions
;;;    1 --> center --> G --> Inn --> 1,
;;;    1 --> Inn --> Aut --> Out --> 1.

;;; Central extensions.  Wreath products.

;;; Find all extensions of two given groups, with a view to finding all
;;; groups of a given order.

;;; Put in other classical groups.

;;; Put in other sporadic groups, esp. the Mathieu groups.

;;; Make S_n fill in the wedge's and sign tensor wedge's in all cases.

;;; Put in as much as possible from Serre, Fulton-Harris, and books and
;;; articles on representations of linear groups.

;;; Implement the result of AbelianGroup#getSNF using
;;; ProductGroupInternal.  Make corresponding changes to
;;; getIsom(From|To)SNF. (?)
